<!DOCTYPE html>
<meta charset="utf8" />

<emu-clause id="sec-primitive-data-structures">
  <h1>Immutable Data Structures</h1>

  <emu-clause id="sec-record-objects">
    <h1>Record Objects</h1>
    <emu-clause id="sec-record-constructor">
      <h1>The Record Constructor</h1>
      <p>The Record constructor:</p>
      <ul>
        <li>is the intrinsic object <dfn>%Record%</dfn>.</li>
        <li>is the initial value of the *"Record"* property of the global object.</li>
        <li>creates and initializes a new Record value when called as a function.</li>
        <li>is not intended to be used with the `new` operator or to be subclassed. It may be used as the value of an *extends* clause of a class definition but a *super* call to the Record constructor will cause an exception.</li>
      </ul>
      <emu-clause id="sec-record-constructor-record-value">
        <h1>Record ( _arg_ )</h1>
        <p>When the `Record` function is called, the following steps are taken:</p>
        <emu-alg>
          1. If NewTarget is not *undefined*, throw a *TypeError* exception.
          1. Let _obj_ be ? ToObject(_arg_).
          1. Let _keys_ be ? _obj_.[[OwnPropertyKeys]]().
          1. Let _fields_ be a new empty List.
          1. For each element _key_ of _keys_, do
            1. Let _desc_ be ? _obj_.[[GetOwnProperty]](_key_).
            1. If _desc_ is not *undefined* and _desc_.[[Enumerable]] is *true*, then
              1. If Type(_key_) is Symbol, throw a *TypeError* exception.
              1. Let _value_ be ? Get(_obj_, _key_).
              1. If Type(_value_) is Object, throw a *TypeError* exception.
              1. Let _field_ be the Record { [[Key]]: _key_, [[Value]]: _value_ }.
              1. Append _field_ to the end of list _fields_.
          1. Return CreateRecord(_fields_).
        </emu-alg>
      </emu-clause>
    </emu-clause>
    <emu-clause id="sec-properties-of-the-record-constructor">
      <h1>Properties of the Record Constructor</h1>
      <p>The Record constructor:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
        <li>has the following properties:</li>
      </ul>
      <emu-clause id="sec-record.fromentries">
        <h1>Record.fromEntries ( _iterable_ )</h1>
        <p>The *fromEntries* function takes one argument _iterable_, and performs the following steps:</p>
        <emu-alg>
          1. Perform ? RequireObjectCoercible(_iterable_).
          1. Let _fields_ be a new empty List.
          1. Let _adder_ be a new Abstract Closure with parameters (_key_, _value_) that captures _fields_ and performs the following steps when called:
            1. Let _keyString_ be ? ToString(_key_).
            1. If Type(_value_) is Object, throw a *TypeError* exception.
            1. Let _field_ be { [[Key]]: _keyString_, [[Value]]: _value_ }.
            1. Append _field_ to the end of list _fields_.
          1. Perform ? AddEntriesFromIterable(*undefined*, _iterable_, _adder_).
          1. Let _uniqueEntries_ be DeduplicateRecordEntries(_fields_).
          1. Return CreateRecord(_uniqueEntries_).
        </emu-alg>
        <emu-note>
          <p>The parameter _iterable_ is expected to be an object that implements an @@iterator method that returns an iterator object that produces a two element array-like object whose first element is a value that will be used as a Map key and whose second element is the value to associate with that key.</p>
        </emu-note>
      </emu-clause>
      <emu-clause id="sec-record.prototype">
        <h1>Record.prototype</h1>
        <p>The initial value of *Record.prototype* is the value *null*.</p>

        <p>This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.</p>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-tuple-objects">
    <h1>Tuple Objects</h1>
    <emu-clause id="sec-tuple-constructor">
      <h1>The Tuple Constructor</h1>
      <p>The Tuple constructor:</p>
      <ul>
        <li>is the intrinsic object <dfn>%Tuple%</dfn>.</li>
        <li>is the initial value of the *"Tuple"* property of the global object.</li>
        <li>creates and initializes a new Tuple object when called as a function.</li>
        <li>is not intended to be used with the `new` operator or to be subclassed. It may be used as the value of an *extends* clause of a class definition but a *super* call to the Tuple constructor will cause an exception.</li>
      </ul>
      <emu-clause id="sec-tuple-items">
        <h1>Tuple ( ..._items_ )</h1>
        <p>When the `Tuple` function is called with zero or more arguments, the following steps are taken:</p>
        <emu-alg>
          1. If NewTarget is not *undefined*, throw a *TypeError* exception.
          1. Let _items_ be the List of arguments passed to this function.
          1. For each element _e_ of _items_, do
            1. If Type(_e_) is Object, throw a *TypeError* exception.
          1. Let _tuple_ be a new Tuple value whose [[Sequence]] is _items_.
          1. Return _tuple_.
        </emu-alg>
      </emu-clause>
    </emu-clause>
    <emu-clause id="sec-properties-of-the-tuple-constructor">
      <h1>Properties of the Tuple Constructor</h1>
      <p>The Tuple constructor:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
        <li>has the following properties:</li>
      </ul>
      <emu-clause id="sec-tuple.from">
        <h1>Tuple.from ( _items_ [ , _mapfn_ [ , _thisArg_ ] ] )</h1>
        <p>When the `from` method is called with argument _items_ and optional arguments _mapfn_ and _thisArg_, the following steps are taken:</p>
        <emu-alg>
          1. If _mapfn_ is *undefined*, let _mapping_ be *false*.
          1. Else,
            1. If IsCallable(_mapfn_) is *false*, throw a *TypeError* exception.
            1. Let _mapping_ be *true*.
          1. Let _list_ be a new empty List.
          1. Let _k_ be 0.
          1. Let _usingIterator_ be ? GetMethod(_items_, @@iterator).
          1. If _usingIterator_ is not *undefined*, then
            1. Let _closure_ be a new Abstract Closure with parameter (_value_) that captures (_list_, _mapFn_, _thisArg_, _mapping_, _k_) and performs the following steps when called:
              1. If _k_ &ge; 2<sup>53</sup> - 1, throw a *TypeError* exception.
              1. If _mapping_ is *true*, then
                1. Let _mappedValue_ be ? Call(_mapfn_, _thisArg_, &laquo; _value_, ùîΩ(_k_) &raquo;).
              1. Else, let _mappedValue_ be _value_.
              1. If Type(_mappedValue_) is Object, throw a *TypeError* exception.
              1. Append _mappedValue_ to _list_.
              1. Set _k_ to _k_ + 1.
            1. Let _adder_ be CreateBuiltinFunction(_closure_, 1, *""*, &laquo; &raquo;).
            1. Perform ? AddValuesFromIterable(*undefined*, _items_, _adder_, _usingIterator_).
            1. Return a new Tuple value whose [[Sequence]] is _list_.
          1. NOTE: _items_ is not an Iterable so assume it is an array-like object.
          1. Let _arrayLike_ be ! ToObject(_items_).
          1. Let _len_ be ? LengthOfArrayLike(_arrayLike_).
          1. Repeat, while _k_ &lt; _len_,
            1. Let _Pk_ be ! ToString(_k_).
            1. Let _kValue_ be ? Get(_arrayLike_, _Pk_).
            1. If _mapping_ is *true*, then
              1. Let _mappedValue_ be ? Call(_mapfn_, _thisArg_, &laquo; _kValue_, _k_ &raquo;).
            1. Else, let _mappedValue_ be _kValue_.
            1. If Type(_mappedValue_) is Object, throw a *TypeError* exception.
            1. Append _mappedValue_ to _list_.
            1. Set _k_ to _k_ + 1.
          1. Return a new Tuple value whose [[Sequence]] is _list_.
        </emu-alg>
      </emu-clause>
      <emu-clause id="sec-tuple.of">
        <h1>Tuple.of ( ..._items_ )</h1>
        <p>The *of* method takes any number of arguments, and performs the following steps:</p>
        <emu-alg>
          1. Let _items_ be the List of arguments passed to this function.
          1. For each element _e_ of _items_, do
            1. If Type(_e_) is Object, throw a *TypeError* exception.
          1. Let _tuple_ be a new Tuple value whose [[Sequence]] is _items_.
          1. Return _tuple_.
        </emu-alg>
      </emu-clause>
      <emu-clause id="sec-tuple.prototype">
        <h1>Tuple.prototype</h1>
        <p>The initial value of *Tuple.prototype* is %Tuple.prototype%</p>
        <p>This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.</p>
      </emu-clause>
    </emu-clause>
    <emu-clause id="sec-properties-of-the-tuple-prototype-object">
      <h1>Properties of the Tuple Prototype Object</h1>
      <p>The Tuple prototype object:</p>
      <ul>
        <li>is an ordinary object.</li>
        <li>is not a Tuple object; it does not have a [[TupleData]] internal slot.</li>
        <li>has a [[Prototype]] internal slot whose value is *null*.</li>
      </ul>
      <emu-clause id="sec-thistuplevalue" type="abstract operation">
        <h1>
          <ins>
            thisTupleValue (
              _value_: unknown,
            ): either a normal completion containing a Tuple or a throw completion
          </ins>
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It throws an exception unless _O_ is an Object and has the given internal slot.</dd>
        </dl>
        <emu-alg>
          1. If Type(_value_) is Tuple, return _value_.
          1. If Type(_value_) is Object and _value_ has a [[TupleData]] internal slot, then
            1. Let _t_ be _value_.[[TupleData]].
            1. Assert: Type(_t_) is Tuple.
            1. Return _t_.
          1. Throw a *TypeError* exception.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-tuple.prototype.constructor">
        <h1>Tuple.prototype.constructor</h1>
        <p>The initial value of *Tuple.prototype.constructor* is the intrinsic object %Tuple%</p>
      </emu-clause>
      <emu-clause id="sec-tuple.prototype.at">
        <h1>Tuple.prototype.at ( _index_ )</h1>
        <p>`Tuple.prototype.at` is a distinct function that implements the same algorithm as `Array.prototype.at` as defined in <emu-xref href="#sec-array.prototype.at"></emu-xref> except that ? thisTupleValue(*this* value) is used instead of directly accessing the *this* value. The implementation of the algorithm may be optimized with the knowledge that the *this* value is an object that has a fixed length and whose <emu-xref href="#integer-index">integer-indexed</emu-xref> properties are not sparse, do not change, and their access is not observable. However, such optimization must not introduce any observable changes in the specified behaviour of the algorithm.</p>
        <p>This function is not generic, since thisTupleValue(*this* value) can return an abrupt completion: in that case, that exception is thrown instead of evaluating the algorithm.</p>
      </emu-clause>
      <emu-clause id="sec-tuple.prototype.valueof">
        <h1>Tuple.prototype.valueOf ( )</h1>
        <p>When the `valueOf` function is called, the following steps are taken:</p>
        <emu-alg>
          1. Return ? thisTupleValue(*this* value).
        </emu-alg>
      </emu-clause>
      <emu-clause id="sec-tuple.prototype-@@toStringTag">
        <h1>Tuple.prototype [ @@toStringTag ]</h1>
        <p>The initial value of *Tuple.prototype[@@toStringTag]* is the String value *"Tuple"*.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
      <emu-clause id="sec-tuple.prototype.slice">
        <h1>Tuple.prototype.slice ( _start_, _end_ )</h1>
        <p>When the `slice` method is called with two arguments, _start_ and _end_, and returns a Tuple containing the elements of the Tuple from element _start_ up to, but not including, element _end_ (or through the end of the tuple if _end_ is *undefined*). If _start_ is negative, it is treated as <emu-eqn>_length_ + _start_</emu-eqn> where _length_ is the length of the tuple. If _end_ is negative, it is treated as <emu-eqn>_length_ + _end_</emu-eqn> where _length_ is the length of the tuple.</p>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Let _T_ be ? thisTupleValue(*this* value).
          1. Let _list_ be _T_.[[Sequence]].
          1. Let _len_ be the number of elements in _list_.
          1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).
          1. If _relativeStart_ is -&infin;, let _k_ be 0.
          1. Else if _relativeStart_ &lt; 0, let _k_ be max((_len_ + _relativeStart_), 0); else let _k_ be min(_relativeStart_, _len_).
          1. If _end_ is *undefined*, let _relativeEnd_ be _len_; else let _relativeEnd_ be ? ToIntegerOrInfinity(_end_).
          1. If _relativeEnd_ is -&infin;, let _final_ be 0.
          1. Else if _relativeEnd_ &lt; 0, let _final_ be max((_len_ + _relativeEnd_), 0); else let _final_ be min(_relativeEnd_, _len_).
          1. Let _newList_ be a new empty List.
          1. Repeat, while _k_ &lt; _final_,
            1. Let _kValue_ be _list_[_k_].
            1. Assert: Type(_kValue_) is not Object.
            1. Append _kValue_ to the end of _newList_.
            1. Set _k_ to _k_ + 1.
          1. Return a new Tuple value whose [[Sequence]] is _newList_.
        </emu-alg>
      </emu-clause>
      <emu-clause id="sec-tuple.prototype.concat">
        <h1>Tuple.prototype.concat ( ..._args_ )</h1>
        <p>When the *concat* method is called with zero or more arguments, it returns a Tuple containing the elements of the Tuple followed by the elements of each argument in order.</p>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Let _T_ be ? thisTupleValue(*this* value).
          1. Let _list_ be a new empty List.
          1. Let _n_ be 0.
          1. Let _items_ be a List whose first element is _T_ and whose subsequent element are, in left to right order, the arguments that were passed to this function invocation.
          1. Repeat, while _items_ is not empty,
            1. Remove the first element from _items_ and let _E_ be the value of the element.
            1. Let _spreadable_ be ? IsConcatSpreadable(_E_).
            1. If _spreadable_ is *true*, then
              1. Let _k_ be 0.
              1. Let _len_ be ? LengthOfArrayLike(_E_).
              1. If _n_ + _len_ &gt; 2<sup>53</sup> - 1, throw a *TypeError* exception.
              1. Repeat, while _k_ &lt; _len_,
                1. Let _P_ be ! ToString(_k_).
                1. Let _exists_ be ? HasProperty(_E_, _P_).
                1. If _exists_ is *true*, then
                  1. Let _subElement_ be ? Get(_E_, _P_).
                  1. If Type(_subElement_) is Object, throw a *TypeError* exception.
                  1. Append _subElement_ to the end of list _list_.
                1. Set _n_ to _n_ + 1.
                1. Set _k_ to _k_ + 1.
            1. Else,
              1. NOTE: _E_ is added as a single item rather than spread.
              1. If _n_ &ge; 2<sup>53</sup> - 1, throw a *TypeError* exception.
              1. If Type(_E_) is Object, throw a *TypeError* exception.
              1. Append _E_ to the end of list _list_.
              1. Set _n_ to _n_ + 1.
          1. Return a new Tuple value whose [[Sequence]] is _list_.
        </emu-alg>
      </emu-clause>
      <emu-clause id="sec-tuple.prototype.includes">
        <h1>Tuple.prototype.includes ( _searchElement_ [ , _fromIndex_ ] )</h1>
        <p>`Tuple.prototype.includes` is a distinct function that implements the same algorithm as `Array.prototype.includes` as defined in <emu-xref href="#sec-array.prototype.includes"></emu-xref> except that ? thisTupleValue(*this* value) is used instead of directly accessing the *this* value. The implementation of the algorithm may be optimized with the knowledge that the *this* value is an object that has a fixed length and whose <emu-xref href="#integer-index">integer-indexed</emu-xref> properties are not sparse, do not change, and their access is not observable. However, such optimization must not introduce any observable changes in the specified behaviour of the algorithm.</p>
        <p>This function is not generic, since thisTupleValue(*this* value) can return an abrupt completion: in that case, that exception is thrown instead of evaluating the algorithm.</p>
      </emu-clause>
      <emu-clause id="sec-tuple.prototype.indexof">
        <h1>Tuple.prototype.indexOf ( _searchElement_ [ , _fromIndex_ ] )</h1>
        <p>`Tuple.prototype.indexOf` is a distinct function that implements the same algorithm as `Array.prototype.indexOf` as defined in <emu-xref href="#sec-array.prototype.indexof"></emu-xref> except that ? thisTupleValue(*this* value) is used instead of directly accessing the *this* value. The implementation of the algorithm may be optimized with the knowledge that the *this* value is an object that has a fixed length and whose <emu-xref href="#integer-index">integer-indexed</emu-xref> properties are not sparse, do not change, and their access is not observable. However, such optimization must not introduce any observable changes in the specified behaviour of the algorithm.</p>
        <p>This function is not generic, since thisTupleValue(*this* value) can return an abrupt completion: in that case, that exception is thrown instead of evaluating the algorithm.</p>
      </emu-clause>
      <emu-clause id="sec-tuple.prototype.join">
        <h1>Tuple.prototype.join ( _separator_ )</h1>
        <p>`Tuple.prototype.join` is a distinct function that implements the same algorithm as `Array.prototype.join` as defined in <emu-xref href="#sec-array.prototype.join"></emu-xref> except that ? thisTupleValue(*this* value) is used instead of directly accessing the *this* value. The implementation of the algorithm may be optimized with the knowledge that the *this* value is an object that has a fixed length and whose <emu-xref href="#integer-index">integer-indexed</emu-xref> properties are not sparse, do not change, and their access is not observable. However, such optimization must not introduce any observable changes in the specified behaviour of the algorithm.</p>
        <p>This function is not generic, since thisTupleValue(*this* value) can return an abrupt completion: in that case, that exception is thrown instead of evaluating the algorithm.</p>
      </emu-clause>
      <emu-clause id="sec-tuple.prototype.lastindexof">
        <h1>Tuple.prototype.lastIndexOf ( _searchElement_ [ , _fromIndex_ ] )</h1>
        <p>`Tuple.prototype.lastIndexOf` is a distinct function that implements the same algorithm as `Array.prototype.lastIndexOf` as defined in <emu-xref href="#sec-array.prototype.lastindexof"></emu-xref> except that ? thisTupleValue(*this* value) is used instead of directly accessing the *this* value. The implementation of the algorithm may be optimized with the knowledge that the *this* value is an object that has a fixed length and whose <emu-xref href="#integer-index">integer-indexed</emu-xref> properties are not sparse, do not change, and their access is not observable. However, such optimization must not introduce any observable changes in the specified behaviour of the algorithm.</p>
        <p>This function is not generic, since thisTupleValue(*this* value) can return an abrupt completion: in that case, that exception is thrown instead of evaluating the algorithm.</p>
      </emu-clause>
      <emu-clause id="sec-tuple.prototype.entries">
        <h1>Tuple.prototype.entries ( )</h1>
        <p>When the *entries* method is called, it returns an iterator over the entries of the Tuple.</p>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Let _tuple_ be ? thisTupleValue(*this* value).
          1. Let _O_ be ! ToObject(_tuple_).
          1. Return CreateArrayIterator(_O_, ~key+value~).
        </emu-alg>
      </emu-clause>
      <emu-clause id="sec-tuple.prototype.every">
        <h1>Tuple.prototype.every ( _callbackfn_ [ , _thisArg_ ] )</h1>
        <p>`Tuple.prototype.every` is a distinct function that implements the same algorithm as `Array.prototype.every` as defined in <emu-xref href="#sec-array.prototype.every"></emu-xref> except that ? thisTupleValue(*this* value) is used instead of directly accessing the *this* value. The implementation of the algorithm may be optimized with the knowledge that the *this* value is an object that has a fixed length and whose <emu-xref href="#integer-index">integer-indexed</emu-xref> properties are not sparse, do not change, and their access is not observable. However, such optimization must not introduce any observable changes in the specified behaviour of the algorithm.</p>
        <p>This function is not generic, since thisTupleValue(*this* value) can return an abrupt completion: in that case, that exception is thrown instead of evaluating the algorithm.</p>
      </emu-clause>
      <emu-clause id="sec-tuple.prototype.filter">
        <h1>Tuple.prototype.filter ( _callbackfn_ [ , _thisArg_ ] )</h1>
        <emu-note>
          <p>_callbackfn_ should be a function that accepts three arguments and returns a value that is coercible to the Boolean value *true* or *false*. `filter` calls _callbackfn_ once for each element in the tuple, in ascending order, and constructs a new tuple of all the values for which _callbackfn_ returns *true*.</p>
          <p>If a _thisArg_ parameter is provided, it will be used as the *this* value for each invocation of _callbackfn_. If it is not provided, *undefined* is used instead.</p>
          <p>_callbackfn_ is called with three arguments: the value of the element, the index of the element, and the Tuple being traversed.</p>
        </emu-note>
        <p>When the `filter` method is called with one or two arguments, the following steps are taken:</p>
        <emu-alg>
          1. Let _T_ be ? thisTupleValue(*this* value).
          1. Let _list_ be _T_.[[Sequence]].
          1. Let _len_ be the number of elements in _list_.
          1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.
          1. Let _newList_ be a new empty List.
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _kValue_ be _list_[_k_].
            1. Let _selected_ be ToBoolean(? Call(_callbackfn_, _thisArg_, &laquo; _kValue_, _k_, _T_ &raquo;)).
            1. If _selected_ is *true*, then
              1. Append _kValue_ to the end of list _newList_.
            1. Set _k_ to _k_ + 1.
          1. Return a new Tuple value whose [[Sequence]] is _newList_.
        </emu-alg>
      </emu-clause>
      <emu-clause id="sec-tuple.prototype.find">
        <h1>Tuple.prototype.find ( _predicate_ [ , _thisArg_ ] )</h1>
        <p>`Tuple.prototype.find` is a distinct function that implements the same algorithm as `Array.prototype.find` as defined in <emu-xref href="#sec-array.prototype.find"></emu-xref> except that ? thisTupleValue(*this* value) is used instead of directly accessing the *this* value. The implementation of the algorithm may be optimized with the knowledge that the *this* value is an object that has a fixed length and whose <emu-xref href="#integer-index">integer-indexed</emu-xref> properties are not sparse, do not change, and their access is not observable. However, such optimization must not introduce any observable changes in the specified behaviour of the algorithm.</p>
        <p>This function is not generic, since thisTupleValue(*this* value) can return an abrupt completion: in that case, that exception is thrown instead of evaluating the algorithm.</p>
      </emu-clause>
      <emu-clause id="sec-tuple.prototype.findindex">
        <h1>Tuple.prototype.findIndex ( _predicate_ [ , _thisArg_ ] )</h1>
        <p>`Tuple.prototype.findIndex` is a distinct function that implements the same algorithm as `Array.prototype.findIndex` as defined in <emu-xref href="#sec-array.prototype.findindex"></emu-xref> except that ? thisTupleValue(*this* value) is used instead of directly accessing the *this* value. The implementation of the algorithm may be optimized with the knowledge that the *this* value is an object that has a fixed length and whose <emu-xref href="#integer-index">integer-indexed</emu-xref> properties are not sparse, do not change, and their access is not observable. However, such optimization must not introduce any observable changes in the specified behaviour of the algorithm.</p>
        <p>This function is not generic, since thisTupleValue(*this* value) can return an abrupt completion: in that case, that exception is thrown instead of evaluating the algorithm.</p>
      </emu-clause>
      <emu-clause id="sec-tuple.prototype.findlast">
        <h1>Tuple.prototype.findLast ( _predicate_ [ , _thisArg_ ] )</h1>
        <p>`Tuple.prototype.findLast` is a distinct function that implements the same algorithm as `Array.prototype.findLast` as defined in <emu-xref href="#sec-array.prototype.findlast"></emu-xref> except that ? thisTupleValue(*this* value) is used instead of directly accessing the *this* value. The implementation of the algorithm may be optimized with the knowledge that the *this* value is an object that has a fixed length and whose <emu-xref href="#integer-index">integer-indexed</emu-xref> properties are not sparse, do not change, and their access is not observable. However, such optimization must not introduce any observable changes in the specified behaviour of the algorithm.</p>
        <p>This function is not generic, since thisTupleValue(*this* value) can return an abrupt completion: in that case, that exception is thrown instead of evaluating the algorithm.</p>
      </emu-clause>
      <emu-clause id="sec-tuple.prototype.findlastindex">
        <h1>Tuple.prototype.findLastIndex ( _predicate_ [ , _thisArg_ ] )</h1>
        <p>`Tuple.prototype.findLastIndex` is a distinct function that implements the same algorithm as `Array.prototype.findLastIndex` as defined in <emu-xref href="#sec-array.prototype.findlastindex"></emu-xref> except that ? thisTupleValue(*this* value) is used instead of directly accessing the *this* value. The implementation of the algorithm may be optimized with the knowledge that the *this* value is an object that has a fixed length and whose <emu-xref href="#integer-index">integer-indexed</emu-xref> properties are not sparse, do not change, and their access is not observable. However, such optimization must not introduce any observable changes in the specified behaviour of the algorithm.</p>
        <p>This function is not generic, since thisTupleValue(*this* value) can return an abrupt completion: in that case, that exception is thrown instead of evaluating the algorithm.</p>
      </emu-clause>
      <emu-clause id="sec-tuple.prototype.flat">
        <h1>Tuple.prototype.flat ( [ _depth_ ] )</h1>
        <p>When the `flat` method is called with zero or one arguments, the following steps are taken:</p>
        <emu-alg>
          1. Let _T_ be ? thisTupleValue(*this* value).
          1. Let _list_ be _T_.[[Sequence]].
          1. Let _depthNum_ be 1.
          1. If _depth_ is not *undefined*, then
            1. Set _depthNum_ to ? ToIntegerOrInfinity(_depth_).
          1. Let _flat_ be a new empty List.
          1. Perform ? FlattenIntoTuple(_flat_, _list_, _depthNum_).
          1. Return a new Tuple value whose [[Sequence]] is _flat_.
        </emu-alg>

        <emu-clause id="sec-flattenintotuple" aoid="FlattenIntoTuple">
          <h1>FlattenIntoTuple ( _target_, _source_, _depth_ [ , _mapperFunction_, _thisArg_ ] )</h1>
          <p>The abstract operation FlattenIntoTuple takes arguments _target_, _source_, and _depth_ and optional arguments _mapperFunction_ and _thisArg_. It performs the following steps when called:</p>
          <emu-alg>
            1. Assert: _target_ is a List.
            1. Assert: _source_ is a List.
            1. Assert: IsIntegralNumber(_depth_) is *true*, or _depth_ is either *+&infin;*<sub>ùîΩ</sub> or *-&infin;*<sub>ùîΩ</sub>.
            1. Assert: If _mapperFunction_ is present, then IsCallable(_mapperFunction_) is *true*, _thisArg_ is present, and _depth_ is 1.
            1. Let _sourceIndex_ be 0.
            1. For each element _element_ of _source_, do
              1. If _mapperFunction_ is present, then
                1. Set _element_ to ? Call(_mapperFunction_, _thisArg_, &laquo; _element_, _sourceIndex_, _source_ &raquo;).
                1. If Type(_element_) is Object, throw a *TypeError* exception.
              1. If _depth_ &gt; 0 and Type(_element_) is Tuple, then
                1. Perform ? FlattenIntoTuple(_target_, _element_, _depth_ - 1).
              1. Else,
                1. Let _len_ be the length of _target_.
                1. If _len_ &ge; 2<sup>53</sup> - 1, throw a *TypeError* exception.
                1. Append _element_ to _target_.
              1. Set _sourceIndex_ to _sourceIndex_ + 1.
          </emu-alg>
        </emu-clause>
      </emu-clause>
      <emu-clause id="sec-tuple.prototype.flatmap">
        <h1>Tuple.prototype.flatMap ( _mapperFunction_ [ , _thisArg_ ] )</h1>
        <p>When the `flatMap` method is called with one or two arguments, the following steps are taken:</p>
        <emu-alg>
          1. Let _T_ be ? thisTupleValue(*this* value).
          1. Let _list_ be _T_.[[Sequence]].
          1. If IsCallable(_mapperFunction_) is *false*, throw a *TypeError* exception.
          1. Let _flat_ be a new empty List.
          1. Perform ? FlattenIntoTuple(_flat_, _list_, 1, _mapperFunction_, _thisArg_).
          1. Return a new Tuple value whose [[Sequence]] is _flat_.
        </emu-alg>
      </emu-clause>
      <emu-clause id="sec-tuple.prototype.foreach">
        <h1>Tuple.prototype.forEach ( _callbackfn_ [ , _thisArg_ ] )</h1>
        <p>`Tuple.prototype.forEach` is a distinct function that implements the same algorithm as `Array.prototype.forEach` as defined in <emu-xref href="#sec-array.prototype.foreach"></emu-xref> except that ? thisTupleValue(*this* value) is used instead of directly accessing the *this* value. The implementation of the algorithm may be optimized with the knowledge that the *this* value is an object that has a fixed length and whose <emu-xref href="#integer-index">integer-indexed</emu-xref> properties are not sparse, do not change, and their access is not observable. However, such optimization must not introduce any observable changes in the specified behaviour of the algorithm.</p>
        <p>This function is not generic, since thisTupleValue(*this* value) can return an abrupt completion: in that case, that exception is thrown instead of evaluating the algorithm.</p>
      </emu-clause>
      <emu-clause id="sec-tuple.prototype.keys">
        <h1>Tuple.prototype.keys ( )</h1>
        <p>When the *keys* method is called, it returns an iterator over the keys of the Tuple.</p>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Let _tuple_ be ? thisTupleValue(*this* value).
          1. Let _O_ be ! ToObject(_tuple_).
          1. Return CreateArrayIterator(_O_, ~key~).
        </emu-alg>
      </emu-clause>
      <emu-clause id="sec-tuple.prototype.map">
        <h1>Tuple.prototype.map ( _callbackfn_ [ , _thisArg_ ] )</h1>
        <emu-note>
          <p>_callbackfn_ should be a function that accepts three arguments. `map` calls _callbackfn_ once for each element in the Tuple, in ascending order, and constructs a new tuple from the results.</p>
          <p>If a _thisArg_ parameter is provided, it will be used as the *this* value for each invocation of _callbackfn_. If it is not provided, *undefined* is used instead.</p>
          <p>_callbackfn_ is called with three arguments: the value of the element, the index of the element, and the Tuple being traversed.</p>
        </emu-note>
        <p>When the `map` method is called with one or two arguments, the following steps are taken:</p>
        <emu-alg>
          1. Let _T_ be ? thisTupleValue(*this* value).
          1. Let _list_ be _T_.[[Sequence]].
          1. Let _len_ be the number of elements in _list_.
          1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.
          1. Let _newList_ be a new empty List.
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _kValue_ be _list_[_k_].
            1. Let _mappedValue_ be ? Call(_callbackfn_, _thisArg_, &laquo; _kValue_, _k_, _T_ &raquo;).
            1. If Type(_mappedValue_) is Object, throw a *TypeError* exception.
            1. Append _mappedValue_ to the end of list _newList_.
            1. Set _k_ to _k_ + 1.
          1. Return a new Tuple value whose [[Sequence]] is _newList_.
        </emu-alg>
      </emu-clause>
      <emu-clause id="sec-tuple.prototype.reduce">
        <h1>Tuple.prototype.reduce ( _callbackfn_ [ , _thisArg_ ] )</h1>
        <p>`Tuple.prototype.reduce` is a distinct function that implements the same algorithm as `Array.prototype.reduce` as defined in <emu-xref href="#sec-array.prototype.reduce"></emu-xref> except that ? thisTupleValue(*this* value) is used instead of directly accessing the *this* value. The implementation of the algorithm may be optimized with the knowledge that the *this* value is an object that has a fixed length and whose <emu-xref href="#integer-index">integer-indexed</emu-xref> properties are not sparse, do not change, and their access is not observable. However, such optimization must not introduce any observable changes in the specified behaviour of the algorithm.</p>
        <p>This function is not generic, since thisTupleValue(*this* value) can return an abrupt completion: in that case, that exception is thrown instead of evaluating the algorithm.</p>
      </emu-clause>
      <emu-clause id="sec-tuple.prototype.reduceright">
        <h1>Tuple.prototype.reduceRight ( _callbackfn_ [ , _thisArg_ ] )</h1>
        <p>`Tuple.prototype.reduceRight` is a distinct function that implements the same algorithm as `Array.prototype.reduceRight` as defined in <emu-xref href="#sec-array.prototype.reduceright"></emu-xref> except that ? thisTupleValue(*this* value) is used instead of directly accessing the *this* value. The implementation of the algorithm may be optimized with the knowledge that the *this* value is an object that has a fixed length and whose <emu-xref href="#integer-index">integer-indexed</emu-xref> properties are not sparse, do not change, and their access is not observable. However, such optimization must not introduce any observable changes in the specified behaviour of the algorithm.</p>
        <p>This function is not generic, since thisTupleValue(*this* value) can return an abrupt completion: in that case, that exception is thrown instead of evaluating the algorithm.</p>
      </emu-clause>
      <emu-clause id="sec-tuple.prototype.some">
        <h1>Tuple.prototype.some ( _callbackfn_ [ , _thisArg_ ] )</h1>
        <p>`Tuple.prototype.some` is a distinct function that implements the same algorithm as `Array.prototype.some` as defined in <emu-xref href="#sec-array.prototype.some"></emu-xref> except that ? thisTupleValue(*this* value) is used instead of directly accessing the *this* value. The implementation of the algorithm may be optimized with the knowledge that the *this* value is an object that has a fixed length and whose <emu-xref href="#integer-index">integer-indexed</emu-xref> properties are not sparse, do not change, and their access is not observable. However, such optimization must not introduce any observable changes in the specified behaviour of the algorithm.</p>
        <p>This function is not generic, since thisTupleValue(*this* value) can return an abrupt completion: in that case, that exception is thrown instead of evaluating the algorithm.</p>
      </emu-clause>
      <emu-clause id="sec-tuple.prototype.tolocalestring">
        <h1>Tuple.prototype.toLocaleString ( [ _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>`Tuple.prototype.toLocaleString` is a distinct function that implements the same algorithm as `Array.prototype.toLocaleString` as defined in <emu-xref href="#sec-array.prototype.tolocalestring"></emu-xref> except that ? thisTupleValue(*this* value) is used instead of directly accessing the *this* value. The implementation of the algorithm may be optimized with the knowledge that the *this* value is an object that has a fixed length and whose <emu-xref href="#integer-index">integer-indexed</emu-xref> properties are not sparse, do not change, and their access is not observable. However, such optimization must not introduce any observable changes in the specified behaviour of the algorithm.</p>
        <p>This function is not generic, since thisTupleValue(*this* value) can return an abrupt completion: in that case, that exception is thrown instead of evaluating the algorithm.</p>
      </emu-clause>
      <emu-clause id="sec-tuple.prototype.tostring">
        <h1>Tuple.prototype.toString ( )</h1>

        <p>When the *toString* method is called, the following steps are taken:</p>

        <emu-alg>
          1. Let _tuple_ be ? thisTupleValue(*this* value).
          1. Return TupleToString(_tuple_).
        </emu-alg>
      </emu-clause>
      <emu-clause id="sec-tuple.prototype.values">
        <h1>Tuple.prototype.values ( )</h1>
        <p>When the *values* method is called, it returns an iterator over the values of the Tuple.</p>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Let _tuple_ be ? thisTupleValue(*this* value).
          1. Let _O_ be ! ToObject(_tuple_).
          1. Return CreateArrayIterator(_O_, ~value~).
        </emu-alg>
      </emu-clause>
      <emu-clause id="sec-tuple.prototype-@@iterator">
        <h1>Tuple.prototype [ @@iterator ] ( )</h1>
        <p>The initial value of the @@iterator property is %Tuple.prototype.values%.</p>
      </emu-clause>
      <emu-clause id="sec-tuple.prototype.toReversed">
        <h1>Tuple.prototype.toReversed ( )</h1>

        <p>When the *toReversed* method is called, the following steps are taken:</p>

        <emu-alg>
          1. Let _T_ be ? thisTupleValue(*this* value).
          1. Let _oldList_ be a new List containing the elements of _T_.[[Sequence]].
          1. Let _newList_ be a new empty List.
          1. Repeat, while _oldList_ is not empty,
            1. Remove the last element from _oldList_, and let _E_ be the value of the element.
            1. Append _E_ to the end of List _newList_.
          1. Return a new Tuple value whose [[Sequence]] is _newList_.
        </emu-alg>
    </emu-clause>

    <emu-clause id="sec-tuple.prototype.toSorted">
        <h1>Tuple.prototype.toSorted ( _comparefn_ )</h1>

        <p>Except as described below, implements the same requirements as those of `Array.prototype.sort` as defined in <emu-xref href="#sec-array.prototype.sort"></emu-xref>. The implementation may be optimized with the knowledge that the *this* value is an object that has a fixed length and whose <emu-xref href="#integer-index">integer-indexed</emu-xref> properties are not sparse.</p>
        <p>Upon entry, the following steps are performed to initialize evaluation of the `sorted` function. These steps are used instead of the entry steps in <emu-xref href="#sec-array.prototype.sort"></emu-xref>:</p>

        <emu-alg>
          1. If _comparefn_ is not *undefined* and IsCallable(_comparefn_) is *false*, throw a *TypeError* exception.
          1. Let _T_ be ? thisTupleValue(*this* value).
          1. Let _list_ be a new List containing the elements of _T_.[[Sequence]].
          1. Sort _list_ using an implementation-defined sequence of calls to SortCompare. If any such call returns an abrupt completion, stop before performing any further calls to SortCompare or steps in this algorithm and return that completion.
          1. Return a new Tuple value whose [[Sequence]] is _list_.
        </emu-alg>
        <p>The elements of _list_ are sorted in the same order as if they were sorted in an Array via %Array.prototype.sort% with _comparefn_ as the first argument.</p>
    </emu-clause>

    <emu-clause id="sec-tuple.prototype.toSpliced">
        <h1>Tuple.prototype.toSpliced ( _start_, _deleteCount_, ..._items_ )</h1>

        <p>When the `toSpliced` method is called with two or more arguments _start_, _deleteCount_ and zero or more _items_, a new Tuple is returned where the _deleteCount_ elements of the Tuple starting at integer index _start_ are replaced by the arguments _items_.</p>
        <p>The following steps are taken:</p>

        <emu-alg>
          1. Let _T_ be ? thisTupleValue(*this* value).
          1. Let _list_ be _T_.[[Sequence]].
          1. Let _len_ be the number of elements in _list_.
          1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).
          1. If _relativeStart_ &lt; 0, let _actualStart_ be max((_len_ + _relativeStart_), 0); else let _actualStart_ be min(_relativeStart_, _len_).
          1. If the number of actual arguments is 0, then
            1. Let _insertCount_ be 0.
            1. Let _actualDeleteCount_ be 0.
          1. Else if the number of actual arguments is 1, then
            1. Let _insertCount_ be 0.
            1. Let _actualDeleteCount_ be _len_ - _actualStart_.
          1. Else,
            1. Let _insertCount_ be the number of actual arguments minus 2.
            1. Let _dc_ be ? ToIntegerOrInfinity(_deleteCount_).
            1. Let _actualDeleteCount_ be min(max(_dc_, 0), _len_ - _actualStart_).
          1. If _len_ + _insertCount_ - _actualDeleteCount_ &gt; 2<sup>53</sup> - 1, throw a *TypeError* exception.
          1. Let _k_ be 0.
          1. Let _items_ be a List whose elements are, in left to right order, the portion of the actual argument list starting with the third argument. The list is empty if fewer than three arguments were passed.
          1. Let _itemCount_ be the number of elements in _items_.
          1. Let _newList_ be a new empty List.
          1. Repeat, while _k_ &lt; _actualStart_,
            1. Let _E_ be _list_[_k_].
            1. Append _E_ to the end of list _newList_.
            1. Set _k_ to _k_ + 1.
          1. Let _itemK_ be 0.
          1. Repeat, while _itemK_ &lt; _itemCount_,
            1. Let _E_ be _items_[_itemK_].
            1. If Type(_E_) is Object, throw a *TypeError* exception.
            1. Append _E_ to the end of _newList_.
            1. Set _itemK_ to _itemK_ + 1.
          1. Set _k_ to _actualStart_ + _actualDeleteCount_.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _E_ be _list_[_k_].
            1. Append _E_ to the end of _newList_.
            1. Set _k_ to _k_ + 1.
          1. Return a new Tuple value whose [[Sequence]] is _newList_.
        </emu-alg>
      </emu-clause>
      <emu-clause id="sec-tuple.prototype.with">
        <h1>Tuple.prototype.with ( _index_, _value_ )</h1>
        <p>When the *with* method is called with two arguments, it returns a new Tuple with the element at index _index_ replaced with value _value_.</p>
        <emu-alg>
          1. Let _T_ be ? thisTupleValue(*this* value).
          1. Let _list_ be a new List containing the elements of _T_.[[Sequence]].
          1. Let _length_ be the length of list _list_.
          1. Let _relativeIndex_ be ? ToIntegerOrInfinity(_index_).
          1. If _index_ &ge; 0, let _actualIndex_ be _relativeIndex_.
          1. Else, let _actualIndex_ be _len_ + _relativeIndex_.
          1. If _actualIndex_ &ge; _len_ or _actualIndex_ &lt; 0, throw a *RangeError* exception.
          1. If Type(_value_) is Object, throw a *TypeError* exception.
          1. Set _list_[_actualIndex_] to _value_.
          1. Return a new Tuple value whose [[Sequence]] is _list_.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>
